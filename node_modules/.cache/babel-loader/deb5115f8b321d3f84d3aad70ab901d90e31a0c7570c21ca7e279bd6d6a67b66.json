{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  cryptos: [],\n  priceHistory: {},\n  loading: false,\n  error: null,\n  wsConnected: false\n};\nconst TIMEFRAMES = {\n  '1h': 60 * 60 * 1000,\n  '24h': 24 * 60 * 60 * 1000,\n  '7d': 7 * 24 * 60 * 60 * 1000\n};\nconst calculatePercentageChange = (currentPrice, basePrice) => {\n  if (!basePrice) return 0;\n  return (currentPrice - basePrice) / basePrice * 100;\n};\nexport const cryptoSlice = createSlice({\n  name: 'crypto',\n  initialState,\n  reducers: {\n    setCryptos: (state, action) => {\n      state.cryptos = action.payload;\n      // Initialize price history for each crypto\n      action.payload.forEach(crypto => {\n        if (!state.priceHistory[crypto.symbol]) {\n          state.priceHistory[crypto.symbol] = {\n            prices: [],\n            basePrice1h: 0,\n            basePrice24h: 0,\n            basePrice7d: 0,\n            lastUpdateTime: {\n              '1h': 0,\n              '24h': 0,\n              '7d': 0\n            }\n          };\n        }\n      });\n      state.loading = false;\n      state.error = null;\n    },\n    setLoading: (state, action) => {\n      state.loading = action.payload;\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n      state.loading = false;\n    },\n    setWsConnected: (state, action) => {\n      state.wsConnected = action.payload;\n    },\n    updateCryptoPrice: (state, action) => {\n      const {\n        symbol,\n        price,\n        timestamp\n      } = action.payload;\n      const crypto = state.cryptos.find(c => c.symbol === symbol);\n      if (crypto) {\n        // Update current price\n        crypto.price = price;\n        crypto.lastUpdate = timestamp;\n\n        // Initialize price history if not exists\n        if (!state.priceHistory[symbol]) {\n          state.priceHistory[symbol] = {\n            prices: [],\n            basePrice1h: price,\n            basePrice24h: price,\n            basePrice7d: price,\n            lastUpdateTime: {\n              '1h': timestamp,\n              '24h': timestamp,\n              '7d': timestamp\n            }\n          };\n        }\n        const history = state.priceHistory[symbol];\n\n        // Add new price point\n        history.prices.push({\n          price,\n          timestamp\n        });\n\n        // Update base prices if enough time has passed\n        Object.entries(TIMEFRAMES).forEach(([key, timeframe]) => {\n          const lastUpdate = history.lastUpdateTime[key];\n          if (timestamp - lastUpdate >= timeframe) {\n            switch (key) {\n              case '1h':\n                history.basePrice1h = price;\n                break;\n              case '24h':\n                history.basePrice24h = price;\n                break;\n              case '7d':\n                history.basePrice7d = price;\n                break;\n            }\n            history.lastUpdateTime[key] = timestamp;\n          }\n        });\n\n        // Keep only last 7 days of price history\n        const sevenDaysAgo = timestamp - TIMEFRAMES['7d'];\n        history.prices = history.prices.filter(p => p.timestamp >= sevenDaysAgo);\n\n        // Update chart data\n        crypto.chartData = [...crypto.chartData.slice(1), price];\n\n        // Calculate percentage changes\n        crypto.change1h = calculatePercentageChange(price, history.basePrice1h);\n        crypto.change24h = calculatePercentageChange(price, history.basePrice24h);\n        crypto.change7d = calculatePercentageChange(price, history.basePrice7d);\n      }\n    }\n  }\n});\nexport const {\n  setCryptos,\n  setLoading,\n  setError,\n  setWsConnected,\n  updateCryptoPrice\n} = cryptoSlice.actions;\nexport default cryptoSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","cryptos","priceHistory","loading","error","wsConnected","TIMEFRAMES","calculatePercentageChange","currentPrice","basePrice","cryptoSlice","name","reducers","setCryptos","state","action","payload","forEach","crypto","symbol","prices","basePrice1h","basePrice24h","basePrice7d","lastUpdateTime","setLoading","setError","setWsConnected","updateCryptoPrice","price","timestamp","find","c","lastUpdate","history","push","Object","entries","key","timeframe","sevenDaysAgo","filter","p","chartData","slice","change1h","change24h","change7d","actions","reducer"],"sources":["C:/Users/DELL/OneDrive/Desktop/XYZ/src/features/crypto/cryptoSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\n\r\nexport interface CryptoData {\r\n  id: string;\r\n  name: string;\r\n  symbol: string;\r\n  logo: string;\r\n  price: number;\r\n  change1h: number;\r\n  change24h: number;\r\n  change7d: number;\r\n  marketCap: number;\r\n  volume24h: number;\r\n  circulatingSupply: number;\r\n  maxSupply: number | null;\r\n  chartData: number[];\r\n  lastUpdate: number;\r\n}\r\n\r\ninterface PriceHistory {\r\n  [symbol: string]: {\r\n    prices: { price: number; timestamp: number }[];\r\n    basePrice1h: number;\r\n    basePrice24h: number;\r\n    basePrice7d: number;\r\n    lastUpdateTime: { [key: string]: number };\r\n  };\r\n}\r\n\r\ninterface CryptoState {\r\n  cryptos: CryptoData[];\r\n  priceHistory: PriceHistory;\r\n  loading: boolean;\r\n  error: string | null;\r\n  wsConnected: boolean;\r\n}\r\n\r\nconst initialState: CryptoState = {\r\n  cryptos: [],\r\n  priceHistory: {},\r\n  loading: false,\r\n  error: null,\r\n  wsConnected: false\r\n};\r\n\r\nconst TIMEFRAMES = {\r\n  '1h': 60 * 60 * 1000,\r\n  '24h': 24 * 60 * 60 * 1000,\r\n  '7d': 7 * 24 * 60 * 60 * 1000\r\n};\r\n\r\nconst calculatePercentageChange = (currentPrice: number, basePrice: number): number => {\r\n  if (!basePrice) return 0;\r\n  return ((currentPrice - basePrice) / basePrice) * 100;\r\n};\r\n\r\nexport const cryptoSlice = createSlice({\r\n  name: 'crypto',\r\n  initialState,\r\n  reducers: {\r\n    setCryptos: (state, action: PayloadAction<CryptoData[]>) => {\r\n      state.cryptos = action.payload;\r\n      // Initialize price history for each crypto\r\n      action.payload.forEach(crypto => {\r\n        if (!state.priceHistory[crypto.symbol]) {\r\n          state.priceHistory[crypto.symbol] = {\r\n            prices: [],\r\n            basePrice1h: 0,\r\n            basePrice24h: 0,\r\n            basePrice7d: 0,\r\n            lastUpdateTime: {\r\n              '1h': 0,\r\n              '24h': 0,\r\n              '7d': 0\r\n            }\r\n          };\r\n        }\r\n      });\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n    setLoading: (state, action: PayloadAction<boolean>) => {\r\n      state.loading = action.payload;\r\n    },\r\n    setError: (state, action: PayloadAction<string>) => {\r\n      state.error = action.payload;\r\n      state.loading = false;\r\n    },\r\n    setWsConnected: (state, action: PayloadAction<boolean>) => {\r\n      state.wsConnected = action.payload;\r\n    },\r\n    updateCryptoPrice: (state, action: PayloadAction<{\r\n      symbol: string;\r\n      price: number;\r\n      timestamp: number;\r\n    }>) => {\r\n      const { symbol, price, timestamp } = action.payload;\r\n      const crypto = state.cryptos.find(c => c.symbol === symbol);\r\n      \r\n      if (crypto) {\r\n        // Update current price\r\n        crypto.price = price;\r\n        crypto.lastUpdate = timestamp;\r\n        \r\n        // Initialize price history if not exists\r\n        if (!state.priceHistory[symbol]) {\r\n          state.priceHistory[symbol] = {\r\n            prices: [],\r\n            basePrice1h: price,\r\n            basePrice24h: price,\r\n            basePrice7d: price,\r\n            lastUpdateTime: {\r\n              '1h': timestamp,\r\n              '24h': timestamp,\r\n              '7d': timestamp\r\n            }\r\n          };\r\n        }\r\n        \r\n        const history = state.priceHistory[symbol];\r\n        \r\n        // Add new price point\r\n        history.prices.push({ price, timestamp });\r\n        \r\n        // Update base prices if enough time has passed\r\n        Object.entries(TIMEFRAMES).forEach(([key, timeframe]) => {\r\n          const lastUpdate = history.lastUpdateTime[key];\r\n          if (timestamp - lastUpdate >= timeframe) {\r\n            switch(key) {\r\n              case '1h':\r\n                history.basePrice1h = price;\r\n                break;\r\n              case '24h':\r\n                history.basePrice24h = price;\r\n                break;\r\n              case '7d':\r\n                history.basePrice7d = price;\r\n                break;\r\n            }\r\n            history.lastUpdateTime[key] = timestamp;\r\n          }\r\n        });\r\n        \r\n        // Keep only last 7 days of price history\r\n        const sevenDaysAgo = timestamp - TIMEFRAMES['7d'];\r\n        history.prices = history.prices.filter(p => p.timestamp >= sevenDaysAgo);\r\n        \r\n        // Update chart data\r\n        crypto.chartData = [...crypto.chartData.slice(1), price];\r\n        \r\n        // Calculate percentage changes\r\n        crypto.change1h = calculatePercentageChange(price, history.basePrice1h);\r\n        crypto.change24h = calculatePercentageChange(price, history.basePrice24h);\r\n        crypto.change7d = calculatePercentageChange(price, history.basePrice7d);\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport const { \r\n  setCryptos, \r\n  setLoading, \r\n  setError, \r\n  setWsConnected,\r\n  updateCryptoPrice \r\n} = cryptoSlice.actions;\r\n\r\nexport default cryptoSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}